# IoC/DI 를 위한 빈 설정 메타정보 작성

- IoC 컨테이너의 기본적인 역할:  코드를 대신해서 애플리케이션을 구성하는 오브젝트(POJO 클래스, 서비스 오브젝트)를 생성하고 관리하는 것.
- 컨테이너는 빈 설정 메타정보를 통해 빈의 클래스와 이름 등의 정보를 제공받는다.
- IoC 컨테이너가 직접 사용하는 Bean Definition 은 순수한 오브젝트로 표현되는 빈 생성 정보이다.

## 1.2.1 빈 설정 메타 정보

- BeanDefinition(BeanDefinition 은 이후에 BD로 표현) 에는 IoC 컨테이너가 빈을 만들 때 필요한 핵심 정보가 담겨 있다. 
- (몇가지 필수항목을 제외하면 컨테이너에 미리 설정된 디폴트 값이 적용된다.)
- 설정 메타정보는 같지만 이름이 다른 여러개의 빈을 만드는데 BD 는 재사용 될 수 있다.

### 빈 설정 메타 정보 항목

| 이름 | 내용 | 디폴트 값 |
|--------|--------|--------|
| beanClassName | 빈 오브젝트의 클래스 이름. 빈 오브젝트는 이 클래스의 인스턴스가 됨 | 없음, 필수항목!       |
| scope | 빈 오브젝트의 생명주기를 결정하는 스코프를 지정(싱글톤/비싱글톤)       | 싱글톤      |
| lazyInit |빈 오브젝트의 생성을 지연할 것인지를 지정        | false       |
| dependsOn | 먼저 만들어져야 하는 빈을 지정할 수 있다. (순서가 보장돼야 하는 경우 이용)       | 없음       |
| primary |자동와이어링 작업 중 DI 대상 후보가 여러개가 발생하는 경우 최종 선택의 우선권을 부여할 지 여부        | false       |

등등..
// todo 그림으로 변경
 
- 빈 설정 메타 항목 중 가장 중요한 것은 클래스 이름이다. 빈은 오브젝트이고 이를 생성하기 위해선 클래스가 반드시 필요하기 때문이다. (빈 아이디 또한 필수)

## 1.2.2 빈 등록 방법

- 빈 등록은 빈 메타정보를 작성해 컨테이너 에게 건네준다.
- 스프링에서 자주 사용되는 빈의 등록방법은 크게 다섯가지가 있다.

### XML: bean 태그

- 가장 단순하면서 강력한 설정 방법이다.
- 이를 이용하면 스프링 빈 메타정보의 거의 모든 항목을 지정할 수 있으므로 세밀한 제어가 가능하다.

``` xml
<bean id="hello" class="jun.test.Hello">
```

### XML: 네임스페이스와 전용 태그

- 스프링의 빈을 분류하면 크게 애플리케이션의 핵심 코드를 담은 컴포넌트와 서비스 또는 컨테이너 설정을 위한 빈으로 나눈다.
- 위에 본 건 애플리케이션 핵심 로직의 빈이다.
- 반면 컨테이너 설정을 위한 AOP와 같은 빈은 성격이 다르다.
 컨텍스트의 빈 생성 작업 중에 사용하는 AOP를 위한 포인트 컷 오브젝트를 정의하고 기술적인 설정정보를 담고 있을 뿐이다

``` xml
<bean id="pointcut" class="org.springframework.aop.aspectj.AspectJExpressionPointcut">
	<property name="expression" value="execution(* *..*ServiceImpl.upgrade*(..))"/>
</bean>
```

- 컨텍스트가 사용하는 설정정보를 담은 빈과 핵심 로직 빈은 동일하게 bean 태그를 사용함으로 구분이 안된다.
  그래서 스프링은 기술적인 설정과 기반 서비스를 빈으로 등록할 때를 위해 의미가 잘 드러나는 네임스페이스 및 태그 설정방법을 제공한다.

``` xml
<aop:pointcut id="pointcut" expression="execution(* *..*ServiceImpl.upgrade*(..))"/>
```

- 내용이분명하게 드러나고 선언도 깔끔해진다.
- 이런 방법은 스키마가 존재하기 때문에 XML 문서 편집 중에도 즉시 애트리뷰트 타입과 필수 사용 여부등을 검증할 수 있는 장점이 있다.

```xml
<jdbc:embedded-database id="embeddedDatabase" type="HSQL">
	<jdbc:script location="classpath:schema.sql"/>
</jdbc:embedded-database>
```

- 전용 태그 하나로 동시에 여러개의 빈을 만들 수 있는 장점도 있다.

### 자동 인식을 이용한 빈 등록: 스테레오 타입 애노테이션과 빈 스캐너

- 모든 빈을 XML에 일일이 선언하는게 귀찮기도 하고 빈이 많아지면 관리하기가 번거롭다.(충돌도 일어난다.)
- 특정 애노테이션을 설정하고 이를 자동으로 찾아 빈으로 등록해주는 방식을 빈 스캐닝을 통한 자동인식 빈 등록 기능이라고 한다.
- 이를 담당하는 오브젝트를 빈 스캐너라고 한다.
- 빈 스캐너에 내장된 디폴트 필터는 @Component 애노테이션 또는 이를 메타 에노테이션으로 가진 클래스를 선택하여 빈으로 등록시킨다.
- @Component를 포함해 디폴트 필터에 적용되는 애노테이션을 스프링에서 스테레오 타입 에노테이션이라고 부른다.
```java
@Component
public class AnnotationHello  {}
```
- 같은 클래스의 빈이 존재한다면 충돌을 피하기 위해 빈의 이름을 클래스와 다르게 지정할 수 있다.
 ```java
@Component("myAnnotationHello")
public class AnnotationHello  {}
```
- 애노테이션을 부여하고 자동스캔으로 빈을 등록하면 복잡한 XML 문서 생성과 관리에 따른 수고를 덜 수 있다.
- 하지만 등록된 빈들을 한눈에 파악할 수 없다.(상세한 메타항목 지정이 불가하고, 클래스 당 한개의 빈만 등록이 가능하다.)
- 그래도 디폴트 메타정보 항목이면 충분하고 기술 서비스가 아니라면 클래스당 하나 이상의 빈이 등록되는 경우는 거의 없다.

// 예제 소스 참고

1. xml 을 이용한 빈 스캐너 등록
	- XML 설정파일 안에 contxt 스키마 전용 태그를 넣어 빈 스캐너를 등록할 수 있다. (이 태그에 의해 빈 스캐너 해당 패키지를 인식한다.)
```xml
<context:component-scan base-package="jun.spring.ch1"/>
```

2. 빈 스캐너를 내장한 애플리케이션 컨텍스트 사용
	- 빈 스캐너를 내장한 AnnotationConfig(Web)ApplicationContext 를 사용한다.
```xml
 <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
        
        <param-name>contextConfigLocation</param-name>
        <param-value>jun.spring.ch1</param-value>
    </context-param>
```

// 표 1-2

- 각 계층의 핵심 클래스에는 세 가지 스테레오 타입 애노테이션을 사용하고 특정 계층으로 분류하기 힘든 경우에는 @Component를 사용하는 것이 바람직하다.
- 직접 정의한 어노태이션을 사용할 수 도 있다.

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component // @Component 를 메타 애노테이션으로 지정하면 빈 스캐너 디폴트 필터의 자동인식 대상이 된다.
public @interface BusinessRule {
    String value() default "";
}
```

### 자바 코드에 의한 빈 등록: @Configuration 클래스의 @Bean 메소드

- 1장에서 제 3의 존재로 오브젝트 생성과 의존관계 주입을 담당하는 오브젝트를 오브젝트 팩토리라고 불렀다.
- 이 오브젝트 팩토리의 기능을 일반화해서 컨테이너로 만든것이 스프링 컨테이너(빈 팩토리) 이다.
- 빈 팩토리에 설정했던 기능들을 자바로 만드는 방법이 아래와 같다. 이는 자바 코드로 표현되는 메타정보라고 이해하면 좋다.

```java
@Configuration
public class AnnotatedHelloConfig {
    @Bean // 어노테이션으로 하나의 빈을 정의한다. (메소드 이름이 빈의 이름)
    public AnnotatedHello annotatedHello() {
        return new AnnotatedHello(); // 자바 코드를 이용해 빈을 만들고 초기화 후 리턴한다.
    }
}
```

- 자바 코드를 이용한 Bean 등록에 사용되는 클래스는 평범한 자바 코드처럼 동작하지 않는다.
- @Bean 이 붙은 annotatedHello 메소드를 통해 스프링 컨테이너가 얻을 수 있는 정보는 빈 클래스 종류와 이름뿐이다.
- 나머지 설정 메타정보는 모두 Default(싱글톤) 이다
- @Bean 이 붙은 메소드를 이용해서 빈을 만들 때 싱글톤이라면 한개의 오브젝트만 생성되도록 @Bean 메소드를 조작한다.

- 사용하기에 유용한 시기는 빈 스캐닝을 통한 자동인식으로는 등록하기 힘든 기술 서비스 빈의 등록이나 컨테이너 설정용 빈을 XML 없이 등록할 때이다.

- 자바 코드 설정의 유용한 점
	1. 컴파일러나 IDE를 통한 타입 검증이 가능하다.
	2. 자동완성과 같은 IDE 지원 기능을 최대한 이용할 수 있다.
	3. 이해하기 쉽다.
	4. 복잡한 빈 설정이나 초기화 작업을 손쉽게 적용할 수 있다.

### 자바 코드에 의한 빈 등록: 일반 빈 클래스의 @Bean 메소드

- @Configuration이 붙은 클래스가 아닌 POJO 클래스에도 @Bean을 사용할 수 있다.
- @Bean 은 새로운 설정의 메타 정보로 사용되고 리턴 오브젝는 빈이 된다.
- 하지만 이 Bean 은 싱글톤이 아니다.
- 이를 해결하기 위해 클래스내에 변수로 참조하게 끔 만들 수 있다.
- 이런 문제 때문에 함부로 남용하며 안된다.
- 하지만 클래스로 만들어지는 빈과 밀접한 관계가 있는 경우 사용할 수 있다. (설정 정보를 공유하고 외부로 )

// todo 코드

### 빈 등록 메타 정보 구성 전략

- 5가지 대표적인 빈 등록 방법(XML, XML 네임 스페이스/전용태그, 자동 인식을 위한 빈 등록, Configuration 자바 빈 등록, Configuration 사용 안하는 자바 빈 등록)
> 1. XML<br>
> 단순하고 스프링 빈의 메타정보를 거의 모두 지정 가능, 하지만 설정 정보가 많아 질 수 있다.<br>
> 2. XML 네임스페이스/전용 태그<br>
> POJO를 제외한 기술적인 설정과 기반 서비스를 설정하기가 편하다.<br>
> 3. 자동 인식(빈 스캐너)<br>
> 복잡한 XML 문서 관리 요소가 줄어들지만 한눈에 빈을 파악하기 어렵다. 세밀한 설정 제어가 어렵다.<br>
> 4. @Configuration 자바 코드 @Bean 등록<br>
> 타입 검증이 쉽고 보기가 편하다.<br>
> 5. 일반 클래스의 @Bean 등록<br>
> 아직 왜 쓰는지 모르겠다.<br>

> Java Config vs XML ? 모르겠다.<br>
> 어느 것도 낫다고 말할 수 없고 적절하게 조합해서 일관성있게 사용하는 것이 중요하다.

1. XML 단독 사용

- 모든 빈을 XML 에 등록<br>
    - 빈을 한눈에 XML로 확인이 가능하지만 빈이 많아지면 XML 파일을 관리하기 어렵다.<br>
    - POJO 는 빈으로 기반 설정은 네임 스페이스를 이용한다.
     
2. XML과 빈 스캐닝의 혼용

- 기반 서비스 및 설정은 XML 을 이용하고 핵심 빈들은 스테레오 타입 어노테이션을 이용 자동 스캔으로 등록한다.
- 주의점은 스캔 대상 위치를 잘 결정해야 문제가 발생하지 않는다.

// 참고 그림 1-9 멀티 컨텍스트의 중복 빈 스캐닝 문제

3. XML 없이 빈 스캐닝 단독 사용

- 모든 빈들을 자동 등록시키지만 기술 서비스는 자바를 이용한 설정을 적용해야 한다.

## 1.2.3 빈 의존 관계 설정 방법

- DI 할 대상을 선정하는 방법 분류
    - 구체적인 빈을 직접 지정하는 방법
    - 일정한 규칙에 따라 자동으로 선정하는 방법: 오토 와이어링
- 메타정보 작성 방법 분류
    - XML <bean> 태그, 스키마 전용 태그, 애노테이션, 자바 코드에 의한 DI
    
- 각 방법의 특징과 장단점을 익히고 적절하게 조합해서 사용하면 좋다. 서로를 혼용 가능하다. 

### XML: property, constructor-arg

1. property: 수정자 주입

    - property XML 태그를 사용하는 대표적인 방법.
    - ref 애트리뷰트를 통해 bean 을 주입하거나 value 애트리뷰트를 통해 단순 값 또는 빈이 아닌 오브젝트를 주입한다. 
    
```xml
<bean ...>
    <property name="printer" ref="defaultPrinter"/>
    <property name="name" value="Spring"/>
    <property name="age" values="30"/>
    <property name="myClass" value="java.lang.String"/> 
</bean>
<bean id="defaultPrinter" class="..."/>
```

2. constructor: 생성자 주입

- constructor-arg 태그를 통해 빈 또는 값을 주입한다.
- 생성자 파라미터이므로 한번에 여러개를 주입 가능하다. 하지만 파라미터의 순서나 타입을 명시해야 한다.
- 순서가 중요하다.

```java
public class Hello

public Hello(String name, Printer printer) {
    this.name = name;
    this.printer = printer;
}
```

```xml
<bean id="hello" class="jun.spring.ch1.ioc.POJO.Hello">
    <constructor-arg index="0" value="Spring"/>
    <constructor-arg index="1" value="printer"/>
</bean>

<bean id="hello" class="jun.spring.ch1.ioc.POJO.Hello">
    <constructor-arg type="java.lang.String" value="Spring"/>
    <constructor-arg type="jun.spring.ch1.ioc.POJO.Printer" ref="printer"/>
</bean> 

<bean id="hello" class="jun.spring.ch1.ioc.POJO.Hello">
    <constructor-arg type="name" value="Spring"/>
    <constructor-arg type="printer" ref="printer"/>
</bean>
```

### XML: 자동 와이어링

1. byName: 빈 이름 자동와이어링
2. byType: 타입에 의한 자동와이어링

### XML: 네임스페이스와 전용 태그

### 애노테이션: @Resource

1. 수정자 메소드
2. 필드

### 애노테이션: @Autowired / @Inject

1. 수정자 메소드와 필드
2. 생성자
3. 일반 메소드

- 컬렉션과 배열
- @Qualifier
- @javax.inject.Inject
- @javax.inject.Qualifier

### @Autowired와 getBean(), 스프링 테스트

### 자바 코드에 의한 의존관계 설정

1. 애노테이션에 의한 설정 @Autowired, @Resource
2. @Bean 메소드 호출
3. @Bean과 메소드 자동와이어링

### 빈 의존관계 설정 전략

1. XML 단독
2. XML과 애노테이션 설정의 혼합
3. 애노테이션 단독