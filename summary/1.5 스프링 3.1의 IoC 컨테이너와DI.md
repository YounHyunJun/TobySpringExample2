# 스프링 3.1 의 IoC 컨테이너와 DI

> 스프링에 새롭게 도입된 IoC / DI 기술
> - 강화된 자바 코드 빈 설정
>   - 자바 코드를 이용한 빈 메타정보 설정 기능 대폭 확장 
> - 런타임 환경 추상화 
>   - 개발/테스트/운영 단계에서 IoC/DI 구성이 달라질 때 이를 효과적으로 관리할 수 있는 런타임 환경정보 관리기능

- 스프링은 구버전 호환성이 뛰어나므로 3.1 을 사용하지만 그 이전 방식을 사용해도 무방하다.

## 빈의 역할과 구분

### 빈의 종류

#### 애플리케이션 로직 빈

- 스프링 IoC/DI 컨테이너에서 생성하고 관리되는 빈 
- DAO/서비스/컨트롤러 오브젝트(POJO)

#### 애플리케이션 인프라 빈

- 애플리케이션 로직 빈을 지원하는 빈
- DataSource 구현 Object(외부 리소스와의 연결 제공/관리), DataSourceTransactionManager(통합된 트랜잭션의 부가기능) 등..
- 개발자가 직접 작성하는 로직을 담고 있지 않지만 애플리케이션 동작에 직접 참여한다.  

#### 컨테이너 인프라 빈

- 스프링 컨테이너의 기능을 확장해서 빈의 등록/생성/관계설정/초기화 등의 작업에 참여하는 빈
- 자신은 애플리케이션 로직을 담고 있지 않고 다른 빈을 지원하지 않지만 스프렝 컨테이너의 기능에 관여.
- DefaultAdvisorAutoProxyCreator(포인트 컷을 이용 타깃 빈을 선정하고 프록시로 바꿔주는 기능)
- BeanPostProcessor/BeaFactoryPostProcessor 컨테이너의 확장 포인트

### 컨테이너 인프라 빈과 전용 태그

- 컨테이너 인프라 빈이 애플리케이션 로직 빈 / 애플리케이션 인프라 빈과 다른 점
    1. AnnotationAwareAutoProxyCreator 처럼 이름이 길다.
    2. 한 번에 여러개의 빈을 동시에 설정해야 하는 경우가 많다. (여러개의 빈을 동시에 등록하기보다 전용 태그 사용을 권장한다.)
    
- ComponentScan 테스트(ComponentScanTest)

- 컨테이너 인프라 빈은 스프링 컨테이너의 기본 기능을 확장하는 데 사용되고 주로 전용 태그를 통해 간접적으로 등록된다.
- 스프링 3.1 에서 context:annotation-config 를 통해 등록되는 컨테이너 인프라 빈 클래스의 이름
    - ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor
    - ConfigurationClassPostProcessor (테스트 코드 ch151_2)
        - @Configuration / @Bean 을 이용해 새로운 빈을 등록하는 역할
    - AutowiredAnnotationBeanPostProcessor (테스트 코드 ch151_3)
        - @Autowired 가 붙은 필드를 찾아 빈 의존관계를 설정해주는 역할
    - RequiredAnnotationBeanPostProcessor
    - CommonAnnotationBeanPostProcessor
        - @PostConstruct 가 붙은 메소드들이 빈이 초기화 된 뒤에 호출해주는 역할
        
- 가끔 전용 태그에 의해 어떤 빈이 등록되는 지 살펴봐야 하는 이유가 있다. (테스트 코드 ch151_1)
    - @Autowire/@PostConstruct 를 위해 사용 : context:annotation-config
    - @Component 같은 스테레오 타입 빈의 등록을 위해 사용 : context:component-scan base-package=""
    - 위와같이 사용하는 경우가 있지만 이는 잘못된 설정이다.
        - 그 이유는 component-scan 은 빈 스캐너 기능 뿐 아니라 annoation-config 기능 까지 같이 등록해준다.
        - 그 결과로 component-scan 만 사용해도 문제 없다.

- 전용 태그에 의해 등록된 빈을 확인하고 빈의 속성의 설정 여부를 확인하는 유틸리티 클래스를 만들 수 있다. (테스트 코드)

### 빈의 역할

- 스프링 BeanDefinition 에는 ROLE_ 로 시작하는 상수가 있어 역할에 따라 세 가지로 나뉜다
    - ROLE_APPLICATION : 0 
         - 애플리케이션이 동작하는 중에 사용되는 빈(애플리케이션을 구성하는 빈 - 애플리케이션 로직 빈, 애플리케이션 인프라 빈)
    - ROLE_SUPPORT : 1
         - 복합 구조의 빈을 정의할 때 보조적으로 사용하지만 무시해도 좋다.
    - ROLE_INFRASTRUCTURE : 2
         - 컨테이너 인프라 빈
         
- 스프링 3.1 부터는 Role 애노테이션을 도입 역할 값을 사용자가 직접 지정이 가능해졌다.

> 정리<br>
> 빈 메타정보의 역할 속성을 기준<br>
> - 애플리케이션 빈
>   - 애플리케이션 로직 빈
>   - 애플리케이션 인프라 빈(스프링 외부 라이브러리에서 주로 제공)
> - 컨테이너 인프라 빈

## 컨테이너 인프라 빈을 위한 자바 코드 메타정보

- 스프링의 빈을 이렇게 역할에 따라 3가지로 구분하는 이유는??
- 빈 설정 메타정보를 작성하는 방법과 전략을 다르게 가져갈 수 있기 때문..??

### IoC/DI 설정 방법의 발전

- 스프링의 역사
- 스프링 1.x
    - 주로 XML 을 이용한 빈 등록 방법 사용
    - 애플리케이션 로직 빈, 애플리케이션 인프라 빈, 컨테이너 인프란 빈이 모두 bean XML 로 사용되고 그 안에서 혼재되었다.
    - 성격이 다른 빈들이 한 군데 있다보니 규모가 커지고 빈의 개수가 증가해 동작방식을 한눈에 이해하기 어려웠다.
    - 어떤 빈은 이름이 길었다.
- 스프링 2.0
    - 컨테이너 인프라 빈을 손쉽게 사용하도록 의미 있는 스키마와 네임스페이스를 가진 전용 태그를 제공했다.
    - 필요한 경우 직접 커스텀 태그 만들수 있다.
    - 길고 복잡한 이름이 사라지고 aop:config, tx:advice 처럼 짧고 직관적인 태그로 컨테이너 인프라 빈을 등록할 수 있게 되었다.
    - 깔끔해진 XML 을 보고 애플리케이션 구성을 파악하기가 이전보다 편해졌다.
- 스프링 2.5
    - 빈 스캐너와 스테레오 타입 애노테이션을 이용한 빈 자동등록 방식과 애노테이션 기반의 의존관계 설정 방법이 등장했다.
    - 이때부터 XML 에는 주로 애플리케이션 인프라 빈과 전용 태그를 사용하는 컨테이너 인프라 빈만 남게 되었다.
    - 애플리케이션 로직 빈은 내오테이션을 이용해 자바 코드로 작성하게 되었다.
    - 애노테이션을 메타정보로 활용하는 빈 등록과 관계 설정 방식은 외부 클래스를 빈으로 등록할 수 없기 때문에 XML 은 필요했다.
- 스프링 3.0
    - 자바 코드를 이용해 빈 설정정보, 빈 설정 코드를 만드는 일이 가능해졌다.
    - 코드를 이용해 직접 빈을 생성하고 프로퍼티를 지정할 수 있게 되었다.
    - 애플리케이션 인프라 빈도 XML 대신 자바 코드로 정의하는 것이 가능해졌다.
    - 하지만 전용 태그에 의해 등록되는 컨테이너 인프라 빈(내부에서 등록되는 빈)은 쉽게 파악하기 어려우므로 XML 이 아직까지 필요했다.
- 스프링 3.1
    - 컨테이너 인프라 빈도 자바 코드로 등록할 수 있게 되었다.
    - 모든 종류의 빈 설정 방식을 XML 과 자바 코드 중 자유롭게 선택할 수 있게 되었다.
    - XML 없이 자바 코드만으로 빈 설정 메타정보를 작성할 수 있게 되었다.
    
- 설명 그림
// 스프링 버전과 빈 등록 방식

### 자바 코드를 이용한 컨테이너 인프라 빈의 등록

- 스프링 3.1 에서 컨테이너 인프라 빈을 자바 코드로 등록하는 방법
- XML 에서는 컨테이너 인프라 빈을 여러 카테고리로 분류하고 각기 다른 네임 스페이스를 가진 스키마 전용 태그로 정의했다.
- EX) 트랜잭션은 tx, 애플리케이션 컨텍스트는 context
- 자바 코드 설정을 사용할 때는 @Configuration 이 붙은 클래스가 필요하다. (@Bean 이 없어도 컨테이너 인프라 빈 설정을 위해 사용할 수 있다.)

#### @ComponentScan 

- 예제 확인
- 스테레오 타입 애노테이션이 붙은 빈을 자동으로 스캔해서 등록한다.
- 설정한 기반 패키지를 중심으로 스테레오 @Component 같은 스테레오 타입 애노테이션이 붙은 클래스를 모두 찾아 빈으로 등록한다.
- 여러개를 지정해도 된다.
- 패키지 이름 대신 마커 인터페이스를 사용하는 방법도 있다. 마커 인터페이스의 패키지가 기준 패키지가 된다. 
- 패키지 이름의 경우 오타가 날 수 있으므로 마커 인터페이스도 나쁘지 않다.
- 특정 제외하고 싶은 클래스가 있다면 excludeFilter 필드를 사용할 수 있다.

#### @Import

- 예제 확인
- 다른 @Configuration 클래스를 빈 메타정보에 추가할 때 사용한다.
- 특정 기술만 따로 모아놓은 @Configuration 빈 을 만들어 Import 하면 편리하다.

#### @ImportResource

- 예제 확인
- XML 파일의 빈 설정을 가져올 수 있다.

#### @Enable 류

- @Enable 로 시작하는 애노테이션 들이다. XML 에서 사용되던 주요한 전용 태그를 대신 사용할 수 있다.
- @EnableTransactionManagement
    - tx:annotation-driven
    - @Transactional : 트랜잭션이 가능하게 한다.
- @EnableAspectJAutoProxy
    - aop:aspectj-autoproxy
    - @Aspect : AspectJ 를 사용한 Proxy 를 가능하게 한다.
- @EnableAsync
    - @Async : 비동기 처리를 가능하게 한다.
- @EnableCaching
    - @Cacheable : 캐시를 사용할 수 있게 한다.
- @EnableLoadTimeWeaving
    - context:load-time-weaver
    - 객체를 가져올 때 AspectJ 에 의해 weaving 된 객체를 넘겨주는 방식을 가능하게 한다.
    - ex) Compile-Time Weaver: LTW 는 application context 에서 loading 할 때 weaving 하기 때문에 compile 시에 함으로 써 performance 하락을 줄인다.
- @EnableScheduling
    - @Scheduled 을 가능하게 한다. (cron 으로 사용)
- @EnableSpringConfigured
    - context:spring-configured
    - Aspect 에 의한 빈 주입을 가능하게 한다. (보강 필요)
- @EnableWebMvc
    - mvc:annotation-driven
    - MVC 에서 사용할 수 있는 Web 관련된 빈들을 등록해준다. 

## 웹 애플리케이션의 새로운 IoC 컨테이너 구성

### 루트 애플리케이션 컨텍스트 등록

### 서블릿 컨텍스트 등록

## 런타임 환경 추상화와 프로파일

### 환경에 따른 빈 설정정보 변경의 전략과 한계

#### 빈 설정 파일의 변경

#### 프로퍼티 파일 활용

### 런타임 환경과 프로파일

### 활성 프로파일 지정 방법

### 프로파일 활용 전략

## 프로퍼티 소스 

### 프로퍼티

### 스프링에서 사용되는 프로퍼티의 종류

#### 환경변수

#### 시스템 프로퍼티

#### JNDI

#### 서블릿 컨텍스트 파라미터

#### 서블릿 컨픽 파라미터

### 프로파일의 통합과 추상화

### @PropertySource 와 프로퍼티 파일

### 웹 환경에서 사용되는 프로퍼티 소스와 프로퍼티 소스 초기화 오브젝트

 

# BFPP : BeanFactroyPostProcessor
# BPP : BeanPostProcessor

# AnnotationConfigApplicationContext 를 생성할 경우 기본적인 BPP 를 등록하는데 이때 AnnotationConfigUtils 를 사용한다.
# 1. BFPP : ConfigurationClassPostProcessor
# 2. BPP : AutowiredAnnotationBeanPostProcessor (InstantiationAwareBeanPostProcessor)
# 3. BPP : RequiredAnnotationBeanPostProcessor (InstantiationAwareBeanPostProcessor)
# 4. BPP : CommonAnnotationBeanPostProcessor (DestructionAwareBeanPostProcessor)